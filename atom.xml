<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zane&#39;Blog</title>
  <subtitle>定目标，定执行</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zanelove.github.io/"/>
  <updated>2017-07-05T12:43:59.000Z</updated>
  <id>http://zanelove.github.io/</id>
  
  <author>
    <name>Zane</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JNI和NDK编程-JNI调用Java方法的流程</title>
    <link href="http://zanelove.github.io/2015/09/26/JNI%E5%92%8CNDK%E7%BC%96%E7%A8%8B-JNI%E8%B0%83%E7%94%A8Java%E6%96%B9%E6%B3%95%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <id>http://zanelove.github.io/2015/09/26/JNI和NDK编程-JNI调用Java方法的流程/</id>
    <published>2015-09-26T12:10:36.000Z</published>
    <updated>2017-07-05T12:43:59.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;举起酒杯庆祝 大肆谈论那惹人怜的和平世界&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JNI调用Java方法的流程是先通过类名找到类，然后再根据方法名找到方法的id，最后就可以调用这个方法了。如果是调用Java中的非静态方法，那么需要构造出类的对象后才能调用它。下面的例子演示了如何在JNI中调用Java的静态方法，至于调用非静态方法只是多了一些构造对象的过程，这里就不再介绍了。&lt;/p&gt;
&lt;p&gt;首先需要在Java中定义一个静态方法供JNI调用，如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;public static void methodCalledByJni(String msgFromJni) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	Log.d(&amp;quot;----&amp;gt;&amp;quot;, &amp;quot;methodCalledByJni,msg: &amp;quot; + msgFromJni);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://zanelove.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zanelove.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>JNI和NDK编程-JNI的数据类型和类型签名</title>
    <link href="http://zanelove.github.io/2015/09/05/JNI%E5%92%8CNDK%E7%BC%96%E7%A8%8B-JNI%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E7%AD%BE%E5%90%8D/"/>
    <id>http://zanelove.github.io/2015/09/05/JNI和NDK编程-JNI的数据类型和类型签名/</id>
    <published>2015-09-05T12:19:23.000Z</published>
    <updated>2017-07-05T12:48:48.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;So as long as I live I love you, Will heaven and hold you&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JNI的数据类型包含两种：基本类型和引用类型。基本类型主要有jboolean、jchar、jint等，它们和Java中的数据类型的对应关系如表所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170703104016477?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemFuZWxvdmU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://zanelove.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zanelove.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>JNI和NDK编程-NDK的开发流程</title>
    <link href="http://zanelove.github.io/2015/08/29/JNI%E5%92%8CNDK%E7%BC%96%E7%A8%8B-NDK%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>http://zanelove.github.io/2015/08/29/JNI和NDK编程-NDK的开发流程/</id>
    <published>2015-08-29T06:01:42.000Z</published>
    <updated>2017-06-29T07:13:22.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我准备迎接一段美好的时光 沿着海岸 脚踩着沙滩&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NDK的开发流程是基于JNI的，其主要由如下几个步骤。&lt;/p&gt;
&lt;h2 id=&quot;下载NDK&quot;&gt;&lt;a href=&quot;#下载NDK&quot; class=&quot;headerlink&quot; title=&quot;下载NDK&quot;&gt;&lt;/a&gt;下载NDK&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://developer.android.com/ndk/downloads/index.html&quot;&gt;官网下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://pan.baidu.com/s/1hr7CwAC&quot;&gt;云盘下载&lt;/a&gt; (密码：f8h5)&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://zanelove.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zanelove.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>JNI和NDK编程-JNI的开发流程</title>
    <link href="http://zanelove.github.io/2015/08/19/JNI%E5%92%8CNDK%E7%BC%96%E7%A8%8B-JNI%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>http://zanelove.github.io/2015/08/19/JNI和NDK编程-JNI的开发流程/</id>
    <published>2015-08-19T06:01:33.000Z</published>
    <updated>2017-06-29T06:26:33.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;放手一搏吧，别顾虑太多，这就是男人该有的性格&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Java JNI的本意是Java Native Interface（Java本地接口），它是为了方便Java调用C、C++等本地代码所封装的一层接口。我们知道，Java的优点是跨平台，但是作为优点的同时，其在本地交互的时候就出现了短板。Java的跨平台特性导致其本地交互的能力不够强大，一些和操作系统相关的特性Java无法完成，于是Java提供了JNI专门用于和本地代码交互，这样就增强了Java语言的本地交互能力。通过Java JNI，用户可以调用C、C++所编写的本地代码。&lt;/p&gt;
&lt;p&gt;NDK是Android所提供的一个工具集合，通过NDK可以在Android中更加方便地通过JNI来访问本地代码，比如C或者C++。NDK还提供了交叉编译器，开发人员只需要简单地修改mk文件就可以生成特定CPU平台的动态库。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://zanelove.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zanelove.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>View的事件体系View的滑动冲突</title>
    <link href="http://zanelove.github.io/2015/07/28/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB-View%E7%9A%84%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/"/>
    <id>http://zanelove.github.io/2015/07/28/View的事件体系-View的滑动冲突/</id>
    <published>2015-07-28T14:05:17.000Z</published>
    <updated>2017-06-14T14:08:42.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一屋不扫，何以扫天下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;滑动冲突是如何产生的呢？其实在界面中只要外两层同时可以滑动，这个时候就会产生滑动冲突。如果解决滑动冲突呢？这既是一件困难的事又是一件简单的事，说困难是因为许多开发者面对滑动冲突都会显得束手无策，说简单是因为滑动冲突的解决有固定的套路，只要知道了这个固定套路问题就好解决了。通过本节的学习，滑动冲突将不再是个问题。&lt;/p&gt;
&lt;h2 id=&quot;常见的滑动冲突场景&quot;&gt;&lt;a href=&quot;#常见的滑动冲突场景&quot; class=&quot;headerlink&quot; title=&quot;常见的滑动冲突场景&quot;&gt;&lt;/a&gt;常见的滑动冲突场景&lt;/h2&gt;&lt;p&gt;常见的滑动冲突场景可以简单分为如下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;场景1：外部滑动方向和内部滑动方向不一致；&lt;/li&gt;
&lt;li&gt;场景2：外部滑动方向和内部滑动方向一致；&lt;/li&gt;
&lt;li&gt;场景3：上面两种情况的嵌套。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://zanelove.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zanelove.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>View的事件体系-View的事件分发机制</title>
    <link href="http://zanelove.github.io/2015/07/13/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB-View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <id>http://zanelove.github.io/2015/07/13/View的事件体系-View的事件分发机制/</id>
    <published>2015-07-13T11:57:10.000Z</published>
    <updated>2017-06-13T12:19:56.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有人靠天分逆袭，有人靠身份逆袭，如果你什么都没有，也行只要靠格局了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本节介绍View的一个核心知识点：事件分发机制。&lt;/p&gt;
&lt;h2 id=&quot;点击事件的传递规则&quot;&gt;&lt;a href=&quot;#点击事件的传递规则&quot; class=&quot;headerlink&quot; title=&quot;点击事件的传递规则&quot;&gt;&lt;/a&gt;点击事件的传递规则&lt;/h2&gt;&lt;p&gt;在介绍点击事件的传递规则之前，首先我们要明白这里要分析的对象就是MotionEvent，即点击事件，关于&lt;a href=&quot;http://zanelove.github.io/2015/07/04/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB-View%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/&quot;&gt;MotionEvent&lt;/a&gt;已经进行了介绍。所谓点击事件的事件分发，其实就是对MotionEvent事件的分发过程，即当一个MotionEvent产生了以后，系统需要把这个事件传递给一个具体的View，而这个传递的过程就是分发过程。点击事件的分发过程由三个很重要的方法来共同完成：dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent，下面先介绍一下这几个方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://zanelove.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zanelove.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>View的事件体系-弹性滑动</title>
    <link href="http://zanelove.github.io/2015/06/27/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB-%E5%BC%B9%E6%80%A7%E6%BB%91%E5%8A%A8/"/>
    <id>http://zanelove.github.io/2015/06/27/View的事件体系-弹性滑动/</id>
    <published>2015-06-27T11:59:38.000Z</published>
    <updated>2017-06-13T12:18:10.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;你的孤独，虽败犹荣&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上一节讲到了&lt;a href=&quot;http://zanelove.github.io/2017/06/01/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB-View%E7%9A%84%E6%BB%91%E5%8A%A8/&quot;&gt;View的滑动&lt;/a&gt;，我们还要知道如果实现View的弹性滑动，比较生硬地滑动过去，这种方式的用户体验实在太差了，因此我们要实现渐近式滑动。那么如何实现弹性滑动呢？其实实现方法有很多，但是它们都有一个共同思想：将一次大的滑动分成若干次小的滑动并在一个小时间段内完成，弹性滑动的具体的实现方式有很多，比如通过Scroller、Handler#postDelayed以及Thread#sleep等，下面一一进行介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://zanelove.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zanelove.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>View的事件体系-View的滑动</title>
    <link href="http://zanelove.github.io/2015/06/10/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB-View%E7%9A%84%E6%BB%91%E5%8A%A8/"/>
    <id>http://zanelove.github.io/2015/06/10/View的事件体系-View的滑动/</id>
    <published>2015-06-10T14:00:54.000Z</published>
    <updated>2017-06-13T12:17:55.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;愿我所见之人，所历之事，哪怕因为我有一点点的好的改变，我就心满意足了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上一节介绍了View的一些基础知识和概念，本节开始介绍很重要的一个内容：&lt;strong&gt;View的滑动&lt;/strong&gt;。在移动端设备上，不管是Android还是Ios，滑动几乎是应用的标配，不管是下拉刷新还是侧拉滑动（SlidingMenu），它们的基础都是滑动。从另外一方面来说，Android手机由于屏幕比较小，为了给用户呈现更多的内容，就需要使用滑动来隐藏和显示一些内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://zanelove.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zanelove.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>View的事件体系-View的基础知识</title>
    <link href="http://zanelove.github.io/2015/05/24/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB-View%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://zanelove.github.io/2015/05/24/View的事件体系-View的基础知识/</id>
    <published>2015-05-24T11:58:45.000Z</published>
    <updated>2017-06-13T12:17:38.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;If you lose your way, you ‘ll go against the wind from all the wrong directions. 如果失去了方向，那么所有方向吹过了的都是逆风&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然说View不属于四大组件，但是它的作用堪比四大组件，甚至比Receiver和Provider的重要性都要大。在Android中，Activity承担着可视化的功能，同时Android系统提供了很多基础控件，常见的有Button、TextView、CheckBox等。很多时候仅仅使用系统提供的控件是不能满足需求的，因此我们就需要能够根据需求进行新控件的定义，而控件的自定义就需要对Android的View的体系有深入的理解，只有这样才能写出完美的&lt;strong&gt;自定义控件&lt;/strong&gt;。同时Android手机属于移动设备，移动设备的一个特点就是用户可以直接通过屏幕来进行一系列操作，一个典型的场景就是屏幕的滑动，用户可以通过滑动来切换到不同的界面。很多情况下我们的应用都需要支持滑动操作，当处于不同层级的View都可以响应用户的滑动操作时，就会带来一个问题，那就是&lt;strong&gt;滑动冲突&lt;/strong&gt;。如何解决该问题，就需要读者对 &lt;strong&gt;View的事件分发机制&lt;/strong&gt; 有一定的了解。上述内容就是接下来我要和大伙一起探讨的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://zanelove.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zanelove.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>IPC机制-Android中的IPC方式三-Binder连接池、选用合适的IPC方式</title>
    <link href="http://zanelove.github.io/2015/05/08/IPC%E6%9C%BA%E5%88%B6-Android%E4%B8%AD%E7%9A%84IPC%E6%96%B9%E5%BC%8F%E4%B8%89-Binder%E8%BF%9E%E6%8E%A5%E6%B1%A0%E3%80%81%E9%80%89%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84IPC%E6%96%B9%E5%BC%8F/"/>
    <id>http://zanelove.github.io/2015/05/08/IPC机制-Android中的IPC方式三-Binder连接池、选用合适的IPC方式/</id>
    <published>2015-05-08T12:00:59.000Z</published>
    <updated>2017-06-13T12:17:17.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有人说，一个男人变老的两大标志是不断后退的发际线和不断增长的腰围；其实，一个人真正变老的标志是，他觉得人生一眼望得到头，不会再有改变，于是放弃了学习，放弃了提升自己&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Binder连接池&quot;&gt;&lt;a href=&quot;#Binder连接池&quot; class=&quot;headerlink&quot; title=&quot;Binder连接池&quot;&gt;&lt;/a&gt;Binder连接池&lt;/h2&gt;&lt;p&gt;就IPC机制系列中，我们介绍了不同的IPC方式，不同的IPC方式有不同的特点和适用场景。在该节中我们再次介绍一下AIDL，原因是AIDL是一种最常见的进程间通信方式，是日常开发中涉及进程间通信时的首选，所以我们需要额外强调一下它。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://zanelove.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zanelove.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>IPC机制-Android中的IPC方式二-ContentProvider、Socket</title>
    <link href="http://zanelove.github.io/2015/04/30/IPC%E6%9C%BA%E5%88%B6-Android%E4%B8%AD%E7%9A%84IPC%E6%96%B9%E5%BC%8F%E4%BA%8C-ContentProvider%E3%80%81Socket/"/>
    <id>http://zanelove.github.io/2015/04/30/IPC机制-Android中的IPC方式二-ContentProvider、Socket/</id>
    <published>2015-04-30T12:03:50.000Z</published>
    <updated>2017-06-13T12:16:53.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们生活在这个孤独的蓝色星球，无论经历怎样的欢欣与苦痛，在这世界上你永远不是孤身一人，有爱、有梦、有朋友，还有这么美好的世界！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本节继续讲解Android中的IPC方式，在上一节&lt;a href=&quot;http://zanelove.github.io/2017/05/16/IPC%E6%9C%BA%E5%88%B6-Android%E4%B8%AD%E7%9A%84IPC%E6%96%B9%E5%BC%8F%E4%B8%80-Bundle%E3%80%81%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E3%80%81Messenger%E3%80%81AIDL/&quot;&gt;IPC机制-Android中的IPC方式一-Bundle、文件共享、Messenger、AIDL&lt;/a&gt;当中我们已经讲解了如何使用Bundle、文件共享、Messenger以及AIDL来完成跨进程间通信，未阅读该节的读者，不妨进去瞧瞧。&lt;/p&gt;
&lt;p&gt;那么，接下来我将继续为大家讲解上节未完成的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://zanelove.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zanelove.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>IPC机制-Android中的IPC方式一-Bundle、文件共享、Messenger、AIDL</title>
    <link href="http://zanelove.github.io/2015/04/16/IPC%E6%9C%BA%E5%88%B6-Android%E4%B8%AD%E7%9A%84IPC%E6%96%B9%E5%BC%8F%E4%B8%80-Bundle%E3%80%81%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E3%80%81Messenger%E3%80%81AIDL/"/>
    <id>http://zanelove.github.io/2015/04/16/IPC机制-Android中的IPC方式一-Bundle、文件共享、Messenger、AIDL/</id>
    <published>2015-04-16T14:21:13.000Z</published>
    <updated>2017-06-13T12:16:33.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;每一段往上的路都是辛苦的，我们也都有累到想休息的时候，但如果我们就此停下来，甚至往回走，我们就永远到不了山顶了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本节开始详细分析各种跨进程通信（IPC）方式。具体方式有很多，比如可以通过在Intent中附加extras来传递信息（使用Bundle），或者通过共享文件来共享数据，还可以采用Binder方式来跨进程通信，另外，ContentProvider天生就是支持跨进程访问的，因此我们也可以采用它来进行IPC。另外，通过网络通信也是可以实现数据传递的，所以Socket也可以实现IPC。下面会一一进行展开。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://zanelove.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zanelove.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>IPC机制-IPC基础概念介绍</title>
    <link href="http://zanelove.github.io/2015/03/29/IPC%E6%9C%BA%E5%88%B6-IPC%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/"/>
    <id>http://zanelove.github.io/2015/03/29/IPC机制-IPC基础概念介绍/</id>
    <published>2015-03-29T14:15:46.000Z</published>
    <updated>2017-06-13T12:16:02.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;真正的成功，是点亮更多人的人生&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本节主要介绍IPC中的一些基础概念，主要包含三个方面的内容：Serializable接口、Parcelable接口以及Binder，只有熟悉了这三个方面的内容后，才能更好地理解跨进程通信的各种方式。Serializable和Parcelable接口可以完成对象的序列化过程，当我们需要通过Intent和Binder传递对象时就需要使用Serializable或Parcelable。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://zanelove.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zanelove.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>IPC机制-Android中的多进程模式</title>
    <link href="http://zanelove.github.io/2015/03/14/IPC%E6%9C%BA%E5%88%B6-Android%E4%B8%AD%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zanelove.github.io/2015/03/14/IPC机制-Android中的多进程模式/</id>
    <published>2015-03-14T14:19:00.000Z</published>
    <updated>2017-06-13T12:15:35.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;世界如此之大，做一个什么样的自己完全取决于你的选择&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过给四大组件指定android:process属性，我们可以轻易地开启多进程模式，这看起来很简单，但是实际使用过程中却暗藏杀机，有时候我们通过多进程得到的好处甚至都不足以弥补使用多进程所带来的代码层面的负面影响。&lt;/p&gt;
&lt;h2 id=&quot;开启多进程模式&quot;&gt;&lt;a href=&quot;#开启多进程模式&quot; class=&quot;headerlink&quot; title=&quot;开启多进程模式&quot;&gt;&lt;/a&gt;开启多进程模式&lt;/h2&gt;&lt;p&gt;首先，&lt;strong&gt;在Android中使用多进程只有一种方法，那就是通过给四大组件（Activity、Service、Receiver、ContentProvider）在AndroidMenifest.xml中指定android:process属性&lt;/strong&gt;，除此之外没有其他办法，也就是说我们无法给一个进程或一个实体类指定其运行时所在的进程。&lt;strong&gt;其实还有另一种非常规的多进程方法，那就是通过JNI在native层去fork一个新的进程。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://zanelove.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zanelove.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>IPC机制-Android IPC简介</title>
    <link href="http://zanelove.github.io/2015/02/28/IPC%E6%9C%BA%E5%88%B6-Android-IPC%E7%AE%80%E4%BB%8B/"/>
    <id>http://zanelove.github.io/2015/02/28/IPC机制-Android-IPC简介/</id>
    <published>2015-02-28T14:23:51.000Z</published>
    <updated>2017-06-13T12:15:10.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;失败之事十有八九，成与败的区别，就在于如何面对这十有八九的失败，被失败打败的，成了失败者，把失败打败的，成了成功者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;IPC（Inter-Process Communication），含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程。那么，什么是进程又什么是线程？按照操作系统中的描述，线程是CPU调度的最小单元，同时线程是一种有限的系统资源；而进程一般是指一个执行单元，在PC和移动设备上指一个程序或者一个应用。一个进程可以包含多个线程，因此进程和线程是包含与被包含的关系。当然，最简单的情况下，一个进程中可以只有一个线程，即主线程（Android中称为UI线程），在UI线程中才能操作界面元素。很多时候，一个进程中需要执行大量的耗时的任务，如果这些任务放在主线程中去执行就会造成界面无法响应（ANR，Application Not Responding – 应用无响应）。解决这个问题就需要用到线程，把一些耗时的任务放在线程（除UI线程）中即可。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://zanelove.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zanelove.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>IntentFilter的匹配规则</title>
    <link href="http://zanelove.github.io/2015/02/13/IntentFilter%E7%9A%84%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/"/>
    <id>http://zanelove.github.io/2015/02/13/IntentFilter的匹配规则/</id>
    <published>2015-02-13T01:18:01.000Z</published>
    <updated>2017-06-13T12:14:44.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“当下”稍纵即逝，刚刚说出的话立刻就成了过去，很多要说的话却还在未来；活在当下是一个悖论，对时间掐头去尾后，你会发现几乎什么都不会剩下.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;启动Activity分为两种，显示调用和隐式调用。二者的区别简单来说就是：&lt;strong&gt;显示调用需要明确地指定被启动对象的组价信息，包括包名和类名；而隐式调用则不需要明确指定组件信息&lt;/strong&gt;。原则上来说，一个Intent不应该既是显示调用又是隐式调用，如果二者共存的话以显示调用为主。显示调用很简单，这里主要介绍隐式调用。隐式调用需要Intent能够匹配目标组件的IntentFilter中所设置的过滤信息，如果不匹配将无法启动目标Activity。IntentFilter中的过滤信息有action、category、data。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://zanelove.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zanelove.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Activity的启动模式</title>
    <link href="http://zanelove.github.io/2015/01/27/Activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zanelove.github.io/2015/01/27/Activity的启动模式/</id>
    <published>2015-01-27T14:12:58.000Z</published>
    <updated>2017-06-13T12:14:12.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;人最难的是面对真实的自己，面对自己的差距时，很多人总是像鸵鸟一样，把头深深地埋下去，假装看不到外面的世界.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Activity的LaunchMode&quot;&gt;&lt;a href=&quot;#Activity的LaunchMode&quot; class=&quot;headerlink&quot; title=&quot;Activity的LaunchMode&quot;&gt;&lt;/a&gt;Activity的LaunchMode&lt;/h2&gt;&lt;p&gt;首先说一下Activity为什么需要任务栈。我们知道任务栈是一种“后进先出”的栈结构，当栈中无任何Activity的时候，系统就会回收这个任务栈。在默认情况下，我们可能会发现一个问题：多次启动同一个Activity，系统重复创建多个实例，这样不是很傻吗？因此，Android工程师在设计的时候不可能不考虑到这个问题，所以它提供了启动模式来修改系统的默认行为。目前有四种启动模式：standard、singleTop、singleTask和singleInstance。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://zanelove.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zanelove.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Activity的生命周期全面分析</title>
    <link href="http://zanelove.github.io/2015/01/11/Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%85%A8%E9%9D%A2%E5%88%86%E6%9E%90/"/>
    <id>http://zanelove.github.io/2015/01/11/Activity的生命周期全面分析/</id>
    <published>2015-01-11T14:06:04.000Z</published>
    <updated>2017-06-13T12:13:46.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;没错，我们可以选择躺在地上赖着不动：反正我的起点低，反正我家庭不如别人家，有无数个“反正”等着你，但是没有人会看你一眼，每个人都在前行；当别人在飞翔，你依然躺在地上，恐怕你一生的时间都只能用来数伤口了.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本节将Activity的生命周期分为两部分内容，一部分是正常情况下的生命周期，另一部分是异常情况下的生命周期。所谓正常情况下的生命周期，是指在有用户参与的情况下，Activity所经过的生命周期的改变；而异常情况下的生命周期是指Activity被系统回收或者由于当前设备的Configuration发生改变从而导致Activity被销毁重建，异常情况下的生命周期的关注点和正常情况下略有不同。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://zanelove.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zanelove.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Hexo从0到1</title>
    <link href="http://zanelove.github.io/2014/12/25/Hexo%E4%BB%8E0%E5%88%B01/"/>
    <id>http://zanelove.github.io/2014/12/25/Hexo从0到1/</id>
    <published>2014-12-25T12:13:40.000Z</published>
    <updated>2017-06-13T12:13:12.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对程序员而言，最好的简历就是个人博客和GitHub.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、瞧瞧兵器&quot;&gt;&lt;a href=&quot;#一、瞧瞧兵器&quot; class=&quot;headerlink&quot; title=&quot;一、瞧瞧兵器&quot;&gt;&lt;/a&gt;一、瞧瞧兵器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;博客框架：&lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo 3&lt;/a&gt;，这是一款能快速、简洁且高效的博客框架，支持Markdown编辑，自动渲染出漂亮的静态页面。&lt;/li&gt;
&lt;li&gt;前端主题：&lt;a href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;Next&lt;/a&gt;，效果参考:&lt;a href=&quot;http://zanelove.github.io&quot;&gt;http://zanelove.github.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;域名购买：类似万网的平台都可以，你可以选购自己名字的域名，一年几十元左右，两杯咖啡的钱。&lt;/li&gt;
&lt;li&gt;SSL：CloudFlare&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://zanelove.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://zanelove.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Command</title>
    <link href="http://zanelove.github.io/2014/11/24/hexoCommand/"/>
    <id>http://zanelove.github.io/2014/11/24/hexoCommand/</id>
    <published>2014-11-24T09:25:10.000Z</published>
    <updated>2017-06-13T12:12:27.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://zanelove.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://zanelove.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
